# PLEASE DO NOT REDISTRIBUTE !!!
# PLEASE GAIN ACCESS TO LATEST CODE DIRECTLY FROM AUTHOR (IN CASE ANY MODIFICATIONS WERE MADE)

# Author: Sean Parks (sean_parks@fs.fed.us)
# Date: 9.10.2014
# Modified by: Neal McLoughlin
# Last modified: 2020-01-25

# Rationale for this procedure, validation of results, and comparison to other interpolation methods can be found in:
# Parks. 2014. Mapping day-of-burning with coarse-resolution satellite fire-detection data. International Journal of Wildland Fire. 23:215-223.

# NOTE THAT THIS CODE IS SPECIFIC TO FIRE DETECTION DATA OBTAINED FROM: http://activefiremaps.fs.fed.us/gisdata.php

  memory.size(500000)

  library(FNN)
  library(spatstat)
  library(raster)
  library(rgdal)
  library(rgeos)
  library(igraph)

##########################################################################################################
# The est.dob function is divided into the following three stages:
#
# 1. Select those MODIS fire detection points that will be used to model day of burning
# 2. Model day of burning
# 3. Remove small (<= 25 ha) 'regions' that are generated by the interpolation in stage 2
#
# The following arguments are used by the modis.dob function:
#
# fire.poly : spatial polygon data frame object containing a fire perimeter of interest in a projected coordnate system.
#             The data frame must contain the following attributes:
#   fireid : a unique identifier (character) for each fire polygon.
#   mindate : minimum date time (POSIXct) or Julian date (integer) valid for fire.poly, i.e.) remove fire detections prior to this date.
#   maxdate : maximum date time (POSIXct) or Julian date (integer) valid for fire.poly, i.e.) remove fire detections after this date.
#   timezone : time zone (character) valid for fire.poly.
# hotspots : dataframe object containing modis and/or viirs fire detections from the year of fire.poly.
# fuel.mask : raster mask used to align estimated date of burn outputs and mask out non-fuel areas. Must use same projection as fire.poly.
# buffer : numeric buffer distance (meters) used to include fire detection points that fall outside of fire.poly. Defaults to 1000 m.
# rm.25ha : logical indicating if small regions (< 25 ha) should be removed. Default is FALSE. Note that stage 3 requires the 'igraph' package.
# write.dir : optional file directory for writing outputs to. The default "" does not write any output files.
###########################################################################################################


  est.dob <- function(fire.poly, hotspots, fuel.mask, buffer=1000, rm.25ha=FALSE, write.dir="") {

  ######################################################################################################################################
  # Stage 1 selects those fire detetections points that will be used to model day of burning (dob) and write those points to a shapefile
  ######################################################################################################################################

    names(fire.poly@data) <- tolower(names(fire.poly@data))
	
    if(!any(class(fire.poly@data$mindate) == c("POSIXct","integer")) & any(class(fire.poly@data$mindate) != class(fire.poly@data$maxdate))) {
      stop("fire.poly attributes mindate and maxdate must both be of class 'POSIXct' or 'integer'", call.=FALSE)
    }

  # Subset hotspots to spatial extent and min to max dates of fire.poly. MODIS imagery is not available prior to 2001.
	
    fire.buffer <- gBuffer(fire.poly, width=buffer)
    buffer.ext <- as(extent(fire.buffer),"SpatialPolygons")
    buffer.ext@proj4string <- crs(fire.poly)
    buffer.ext <- spTransform(buffer.ext, CRSobj=CRS("+init=epsg:4326"))
    buffer.ext <- buffer.ext@bbox

    # Subset fire detection points that intersect with buffer.ext.

    hotspots <- hotspots[which(hotspots$LONG >= buffer.ext[1,1] & hotspots$LONG <= buffer.ext[1,2] & hotspots$LAT >= buffer.ext[2,1] & hotspots$LAT <= buffer.ext[2,2]),]
    rm(buffer.ext)

    # This step assigns a Julian day to the fire detection data.

    hotspots$GMT <- sapply(X=as.character(hotspots$GMT), FUN=function(x) {paste0(paste(rep("0", times=4 - nchar(x)), collapse=""), x)})
    hotspots$datetime <- as.POSIXct(strptime(x=paste(format(hotspots$DATE, "%Y-%m-%d"), hotspots$GMT), format="%Y-%m-%d %H%M", tz="GMT"))
    attributes(hotspots$datetime)$tzone <- fire.poly@data$timezone
    hotspots$loc_jdate <- as.integer(format(hotspots$datetime, format="%j"))

    # Sometimes fire detections pick up on industrial activities or slash pile burning. 
    # If there are clearly dates when a fire should not be burning, those boundaries can be set here.
    # Remove fire detections that occur on days outside of specified min and max dates.

    if(is.integer(fire.poly@data$mindate)) {
      hotspots <- hotspots[which(hotspots$loc_jdate >= fire.poly@data$mindate & hotspots$loc_jdate <= fire.poly@data$maxdate),]
    } else if(any(class(fire.poly@data$mindate) == "POSIXct")) {
      hotspots <- hotspots[which(hotspots$datetime > fire.poly@data$mindate & hotspots$datetime <= fire.poly@data$maxdate),]
    }

    # Only proceed if there are hotspots associated with the selected fire.poly.

    if(nrow(hotspots) > 0) {

    # Convert hotspots to SpatialPointsDataFrame object and project to match fire.poly

      hotspots <- SpatialPointsDataFrame(coords=hotspots[,c("LONG","LAT")], data=hotspots, proj4string=CRS("+init=epsg:4326"))
      hotspots <- spTransform(x=hotspots, CRSobj=crs(fire.poly))

    # Select fire detection points that intersect with the buffered fire.poly of interest.

      hotspots <- hotspots[fire.buffer,]
      rm(fire.buffer)

    # Assign a chronological ID value for accounting later 

      hotspots@data$id <- sapply(X=1:nrow(hotspots@data), FUN=function(x) {which(order(hotspots@data$datetime) == x)} )

    # This removes fire detections with the same location; they may be on the same date or different dates.
    # This selects the earlier date if there are more than fire detection with the same coordinate.
    # The coordinates function is also needed for finding the nearest neighbors each fire detection.

      coord <- coordinates(hotspots)
      unique.coord <- unique(coord)
      unique.coord <- sapply(X=1:nrow(unique.coord), FUN=function(x) { min(hotspots@data[which(coord[,1] == unique.coord[x,1] & coord[,2] == unique.coord[x,2]),"id"]) })
      hotspots <- hotspots[which(hotspots@data$id %in% unique.coord),]
      rm(list=c("coord","unique.coord"))

    # This is a bit complicated: For some reason that I don't completely understand, there are some fire detection points
    # that are duplicates but were processed by potentially different sources. These sources, for some reason, have slightly
    # different locations and times even though they represent the same pixel that has detected a fire. This sometimes results
    # in two or more fire detections in close proximity with about the same time stamp. This step removes all fire detection 
    # points that are within 10 minutes of each other and within 175 meters of each other. This will remove up to four of these 
    # offending fire detection points.

      for(n in 1:4) {

      # Reset id and coordinates from 'dup' as some fire detections were potentially removed from 'hotspots' during the previous iteration.

        hotspots$id <- 1:nrow(hotspots)
        dup <- cbind(hotspots@data[,c("id","datetime","loc_jdate")], coordinates(hotspots))
        colnames(dup)[4:5] <- c("coords.x1","coords.x2")

      # Generate columns for the nearest fire detections (which) and their respective distances (dist), Julian dates (jdob), and datetimes (dtob).

        dup$which <- nnwhich(dup[,c("coords.x1","coords.x2")], k=1)
        dup$dist <- nndist(dup[,c("coords.x1","coords.x2")], k=1)
        dup$jdob <- dup[dup$which,"loc_jdate"]
        dup$dtob <- dup[dup$which,"datetime"]
        dup$timediff <- abs(difftime(dup$datetime, dup$dtob, units="mins"))

      # This step removes fire detection points within a distance of 175 m and up to 10 min after earlier detection points.

        for(r in 1:nrow(dup)) {
          if (dup[r,"id"] %in% hotspots@data$id & dup[r,"dist"] < 175 & dup[r,"loc_jdate"] == dup[r,"jdob"] & dup[r,"timediff"] < 10) {
            remove.id <- max(dup[r,c("id","which")])
            if(remove.id %in% hotspots@data$id) {
              hotspots <- hotspots[-which(hotspots@data$id == remove.id),] 
            }
            rm(remove.id)
          }
        }
        rm(dup)

      }

    }
	
    # Only proceed if there are more than 5 MODIS fire dectection points.

    if(nrow(hotspots) > 5) {
	
    # Write final hotspots as a ESRI Shapefile to write.dir.

    if(write.dir != "") {
      writeOGR(
        obj=hotspots, 
        dsn=write.dir, 
        layer=paste0(fire.poly@data$fireid,"_hotspots"), 
        driver="ESRI Shapefile", 
        overwrite_layer=TRUE
      )
    }


  #########################################################################################################################
  # Stage 2: generate estimated day-of-burning (dob) based on the 'Weighed by Mean and Distance' (WMD) interpolation method
  #########################################################################################################################

    # Get extent of fire perimeter of interest aligned to fuel.mask

      fire.ext <- alignExtent(extent=extent(fire.poly), object=fuel.mask, snap='near')

    # Make a fire perimeter raster

      pixel.size <- res(fuel.mask)[1]
      proj <- crs(fuel.mask)
      fire.raster <- raster(ext=fire.ext, crs=proj)
      res(fire.raster) <- pixel.size
      fire.raster <- rasterize(fire.poly, fire.raster)

      hotspots$id <- 1:nrow(hotspots)

    # Get xy coordinates for each pixel in area where DOB is to be estimated

      raster.xy <- xyFromCell(fire.raster, 1:ncell(fire.raster), spatial=FALSE)
      raster.xy <- raster.xy[!is.na(extract(x=fire.raster, y=raster.xy)),]

    # For each pixel, find the five closest (nearest neighbour) fire detection points.
    # Make data frame with columns of ten nearest IDs (nn.idex.X), distances (nn.dist.X), and DOBs (dob.X).
    # In theory, you only need five nearest neighbors for this approach to work.

      nn10 <- as.data.frame(get.knnx(data=coordinates(hotspots), query=raster.xy, k=5, algorithm='brute'))
      nn10$pixel.id <- 1:nrow(raster.xy)
      for(nn in 1:5) {
        nn10[,paste0("dob.",nn)] <- hotspots@data[nn10[,paste0("nn.index.",nn)],"loc_jdate"]
      }
      nn10 <- nn10[order(nn10$pixel.id),]

    ######################################################################
    # WEIGHTED by MEAN and DISTANCE (WMD) of 5 nearest neighbours.
    # The average value of the five nearest fire detection points weighted 
    # towards the geographically closer fire detection points.
    ######################################################################

    # This assigns weights to each of the five nearest neignbors

      nn10$dob.tmp <- round(rowMeans(x=nn10[,c("dob.1","dob.2","dob.3","dob.4","dob.5")]))
      for(nn in 1:5) {
        nn10[,paste0("wt.",nn)] <- 1 / (((abs(nn10[,paste0("dob.",nn)] - nn10$dob.tmp) + 1) * nn10[,paste0("nn.dist.",nn)]))
      }
      nn10$wt <- rowSums(nn10[,c("wt.1","wt.2","wt.3","wt.4","wt.5")])
      for(nn in 1:5) {
        nn10[,paste0("wt.",nn)] <- nn10[,paste0("wt.",nn)] / nn10$wt
      }

    # This is the true WMD value

      nn10$dob.tmp <- (nn10$wt.1 * nn10$dob.1) + (nn10$wt.2 * nn10$dob.2) + (nn10$wt.3 * nn10$dob.3) + (nn10$wt.4 * nn10$dob.4) + (nn10$wt.5 * nn10$dob.5)

    # This code ensures that the estimated DOB matches the date of one of the five nearest fire detection points

      nn10$dob.wmd <- apply(X=abs(nn10[,c("dob.1","dob.2","dob.3","dob.4","dob.5")] - nn10[,"dob.tmp"]), MARGIN=1, FUN=which.min)
      for(r in 1:nrow(nn10)) {
        nn10$dob.wmd[r] <- sapply(X=nn10$dob.wmd[r], FUN=function(x){nn10[r,paste0("dob.",x)]})
      }

    # Create raster of modeled DOB

      raster.xy <- cbind(raster.xy, z=nn10$dob.wmd)
      dob.raster <- rasterFromXYZ(raster.xy, res=pixel.size, crs=proj)

    # Mask out non-fuel areas from DOB

      fuel.mask <- crop(x=fuel.mask, y=dob.raster)
      dob.raster <- mask(
        x=dob.raster, 
        mask=fuel.mask, 
        filename=if(write.dir == "") {""} else {paste0(write.dir,"/",fire.poly@data$fireid,"_dob_wmd.tif")}, 
        format="GTiff", 
        options=c("COMPRESS=LZW"), 
        datatype="INT2U", 
        overwrite=TRUE
      )

    # Remove all Stage 2 objects no longer needed.

      rm(list=c("fire.ext","fire.raster","raster.xy","nn10"))

  ################################################################################################################
  # Stage 3: This stage removes the 'small regions' (those that are less than 25 ha) from the modeled DOB
  # This stage is optional. The overall prediction improves a little bit, but maps are WAY more visually appealing
  ################################################################################################################

    if(rm.25ha) {

    # These next steps create 'regions' for all continuous DOB estimates that are less than 25 ha
    # The 'pixel.size' object should account for the cell size you are using
    # and if you want to use a threshold other than 25 ha.
    # This step takes a long time and could use someone with good coding skills to speed it up.

      unique.dob <- unique(dob.raster)
      the.stack <- stack()
      for(u in unique.dob) {
        x <- dob.raster == u
        clump.raster <- clump(x)
        rg.df <- subset(as.data.frame(freq(clump.raster, useNA="no")), count > 0)
        rg.df$from <- rg.df$value - 0.25
        rg.df$to <- rg.df$value + 0.25
        rg.df$becomes = 1
        rg.df$becomes[which(rg.df$count <= pixel.size)] <- 99 
        rg.df$becomes[which(rg.df$count > pixel.size)] <- 1
        rg.df <- as.matrix(rg.df[,c(3:5)])
        the.stack <- addLayer(the.stack, reclassify(clump.raster, rg.df))
        #assign(paste0("clump.raster.", u), reclassify(clump.raster, rg.df))
      }

      names(the.stack) <- paste0("dob",unique.dob)
      small.regions <- merge(the.stack)
	
    #############################################################################
    # Now, a nearest neighbor assignment is given to all pixels that have regions
    # < 25 ha from the nearest pixel that is part of a region > 25 ha.
    #############################################################################

      xy <- as.data.frame(xyFromCell(small.regions, 1:ncell(small.regions), spatial=FALSE))
      xy$extract <- extract(small.regions, xy)
      xy <- na.omit(xy)
      xy$DOB <- extract(dob.raster, xy[,c(1,2)])
      xy$ID <- row.names(xy)

      nibble.df <- subset(xy, extract == 99)
      nibble.df <- nibble.df[,-c(3,4)]
      dob.df <- subset(xy, extract != 99)

      dob.df$ID <- 1:nrow(dob.df)
      dob.df.tmp <- dob.df[,-c(1,2,3)]
      dob.df.tmp$id.tmp <- dob.df.tmp$ID

      nibble.nn <- get.knnx(dob.df[,c(1,2)], cbind(nibble.df$x, nibble.df$y), 1, algorithm='brute')
      nibble.df$id.tmp <- nibble.nn$nn.index

      dob.df.tmp <- dob.df.tmp[,-c(2)]

      nibble.df <- merge(nibble.df, dob.df.tmp, by='id.tmp', all.x=TRUE)
      nibble.df <- nibble.df[,-c(1,4)]

      dob.df <- rbind(dob.df[,c(1,2,4)], nibble.df)

    # This is the final DOB estimate

      dob.raster <- writeRaster(
        x=rasterFromXYZ(dob.df, res=pixel.size, crs=proj), 
        filename=if(write.dir == "") {""} else {paste0(write.dir,"/",fire.poly@data$fireid,"_dob_rm25ha.tif")}, 
        format="GTiff", 
        options=c("COMPRESS=LZW"), 
        datatype='INT2U', 
        overwrite=TRUE
      )

    }

    return(dob.raster)

    } else {

    print(paste("Insufficient hotspots for", fire.poly@data$fireid))

	}
  }
